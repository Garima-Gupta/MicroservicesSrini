Spring Cloud Bus:
-----------------
Spring Cloud Bus links nodes of a distributed system with a lightweight message broker. This can then be used to broadcast state 
changes (e.g. configuration changes) or other management instructions. The only implementation currently is with an AMQP broker as
the transport, but the same basic feature set (and some more depending on the transport) is on the roadmap for other transports.

Spring Cloud Config:
--------------------
Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system. With the Config 
Server you have a central place to manage external properties for applications across all environments. The concepts on both client 
and server map identically to the Spring Environment and PropertySource abstractions, so they fit very well with Spring applications, 
but can be used with any application running in any language.

 As an application moves through the deployment pipeline from dev to test and into production you can manage the configuration between 
 those environments and be certain that applications have everything they need to run when they migrate. 
 
 The default implementation of  the server storage backend uses git so it easily supports labelled versions of configuration environments,
 as well as being accessible  to a wide range of tooling for managing the content. It is easy to add alternative implementations and plug
 them in with Spring  configuration.
 
 https://cloud.spring.io/spring-cloud-config/
 
 Spring Cloud Security:
 ---------------------
 Spring Cloud Security offers a set of primitives for building secure applications and services with minimum fuss. 
 A declarative model which can be heavily configured externally (or centrally) lends itself to the implementation of large 
 systems of co-operating, remote components, usually with a central indentity management service. 
 
 It is also extremely easy to use in a service platform like Cloud Foundry. Building on Spring Boot and Spring Security OAuth2 we 
 can quickly create systems that implement common patterns like single sign on, token relay and token exchange.
 
 Spring Cloud Zookeeper:
 -----------------------
 Spring Cloud Zookeeper provides Apache Zookeeper integrations for Spring Boot apps through autoconfiguration and binding to 
 the Spring Environment and other Spring programming model idioms. With a few simple annotations you can quickly enable and configure 
 the common patterns inside your application and build large distributed systems with Zookeeper. 
 
 The patterns provided include Service Discovery and Distributed Configuration.
 
 Spring Cloud Netflix:
 ---------------------
 Spring Cloud Netflix provides Netflix OSS integrations for Spring Boot apps through autoconfiguration and binding to the Spring 
 Environment and other Spring programming model idioms. With a few simple annotations you can quickly enable and configure the 
 common patterns inside your application and build large distributed systems with battle-tested Netflix components.
 
 The patterns provided include Service Discovery (Eureka), Circuit Breaker (Hystrix), Intelligent Routing (Zuul) and Client Side 
 Load Balancing (Ribbon)..
 
 Spring Cloud Contrast:
 ------------------------
 Spring Cloud Contract is an umbrella project holding solutions that help users in successfully implementing the Consumer Driven Contracts approach. Currently Spring Cloud Contract consists of the Spring Cloud Contract Verifier project.

Spring Cloud Contract Verifier is a tool that enables Consumer Driven Contract (CDC) development of JVM-based applications. It is shipped with Contract Definition Language (DSL) written in Groovy. Stating with version 1.1.0 you can define your own way of defining contracts - the only thing you have to provide is a converter. Contract definitions are used to produce following resources:

by default JSON stub definitions to be used by WireMock (HTTP Server Stub) when doing integration testing on the client code (client tests). Test code must still be written by hand, test data is produced by Spring Cloud Contract Verifier. Starting with version 1.1.0 you can provide your own implementation of the HTTP Server Stub.

Messaging routes if you’re using one. We’re integrating with Spring Integration, Spring Cloud Stream and Apache Camel. You can however set your own integrations if you want to.

Acceptance tests (by default in JUnit or Spock) used to verify if server-side implementation of the API is compliant with the contract (server tests). Full test is generated by Spring Cloud Contract Verifier. Starting with version 1.1.0 you can provide your own way of generating tests (e.g. in a different language).

Spring Cloud Contract Verifier moves TDD to the level of software architecture.
